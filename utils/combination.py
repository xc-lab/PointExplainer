# _*_ coding:utf-8 _*_
'''
This script generates combinations of data augmentation methods

@author: xuechao.wang@ugent.be
'''

from itertools import combinations
from utils.provider import mirror_point_cloud, rotate_point_cloud_by_angle, jitter_point_cloud, random_point_sampling


def combination_method(params_list, dataset, label):
    """
        Generates combinations of augmentation methods for data augmentation.

        Parameters:
        params_list (dict): Dictionary of augmentation methods and their parameters.
        dataset (str): Dataset name (e.g., 'ParkinsonHW').
        label (str): Label indicating class type ('KT' or 'PD').

        Returns:
        list: List of augmentation method combinations.
        """
    tuple_methods = [[{'src': 'copy'}]]

    # Set combination depth (H) based on dataset and label type
    if dataset=='ParkinsonHW' and label=='KT':
        H = 2
    elif dataset=='ParkinsonHW' and label=='PD':
        H = 2

    for i in range(len(list(params_list.keys()))):
        if i < H:
            comb_methods = list(combinations(list(params_list.keys()), i + 1))  # [('mirror'),('rotation'),('jitter'),('mirror','rotation')]

            for comb_method in comb_methods:
                all_method_param_list = []
                temp_result = [[]]
                comb_method = list(comb_method)

                for method in comb_method:
                    method_with_param = []
                    params = params_list[method]
                    for param in params:
                        method_with_param.append({method: param})
                    all_method_param_list.append(method_with_param)

                for pool in all_method_param_list:
                    temp = []
                    for x in temp_result:
                        for y in pool:
                            temp.append(x + [y])
                    temp_result = temp

                tuple_methods.extend(temp_result)
    return tuple_methods


def aug_pc_dataset(pc, result):
    """
        Applies augmentation transformations to a point cloud dataset based on
        specified method combinations.

        Parameters:
        pc (numpy.ndarray): Original point cloud data to augment.
        result (list): List of augmentation method combinations generated by `combination_method`.

        Returns:
        list: Augmented point cloud datasets as per each method combination.

    """
    pc_dataset = []

    for aug_method in result:
        temp_pc = pc.copy()

        for method in aug_method:
            aug = list(method.keys())[0]
            param = list(method.values())[0]
            if aug == 'src':
                temp_pc = temp_pc
            elif aug == 'mirror':
                temp_pc[:, :3] = mirror_point_cloud(temp_pc[:, :3], param)
            elif aug == 'rotation':
                temp_pc[:, :3] = rotate_point_cloud_by_angle(temp_pc[:, :3], param)
            elif aug == 'jitter':
                temp_pc[:, :3] = jitter_point_cloud(temp_pc[:, :3], param)
            elif aug == 'sampling':
                temp_pc = random_point_sampling(temp_pc, param)

            else:
                print('%s is a wrong aug method.' % (aug))

        pc_dataset.append(temp_pc)
    return pc_dataset



if __name__=='__main__':
    '''
        Test code block
    '''
    aug_params_list = {'mirror': ['bottom-up', 'left-right'],
                       'rotation': [90, 180, 270],
                       'jitter': [0.0001],
                       'sampling': [0.5, 0.75, 1.25, 1.5],
                       }

    result = combination_method(aug_params_list)
    print(len(result))






